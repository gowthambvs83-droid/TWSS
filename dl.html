<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Patterns - Learn Data Structures & Algorithms</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        :root {
            --primary: #000;
            --secondary: #fff;
            --accent: #333;
            --highlight: #555;
            --code-bg: #1e1e1e;
            --code-color: #f8f8f2;
            --border: #ddd;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--secondary);
            color: var(--primary);
            line-height: 1.6;
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar Styles */
        .sidebar {
            width: 280px;
            background-color: var(--primary);
            color: var(--secondary);
            padding: 20px;
            overflow-y: auto;
            transition: all 0.3s ease;
        }

        .sidebar-header {
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--highlight);
        }

        .sidebar-header h1 {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .sidebar-header p {
            font-size: 14px;
            opacity: 0.8;
        }

        .nav-section {
            margin-bottom: 25px;
        }

        .nav-title {
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            opacity: 0.7;
        }

        .nav-item {
            display: block;
            padding: 10px 15px;
            margin-bottom: 5px;
            color: var(--secondary);
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .nav-item:hover, .nav-item.active {
            background-color: var(--accent);
        }

        .nav-item i {
            margin-right: 10px;
            width: 16px;
            text-align: center;
        }

        .sub-nav {
            margin-left: 25px;
            display: none;
        }

        .sub-nav.active {
            display: block;
        }

        .sub-nav-item {
            display: block;
            padding: 8px 10px;
            margin-bottom: 3px;
            color: var(--secondary);
            text-decoration: none;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .sub-nav-item:hover, .sub-nav-item.active {
            background-color: var(--highlight);
        }

        /* Main Content Styles */
        .main-content {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }

        .content-header {
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border);
        }

        .content-header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .content-header p {
            font-size: 16px;
            color: var(--accent);
        }

        .content-section {
            margin-bottom: 40px;
            display: none;
        }

        .content-section.active {
            display: block;
        }

        .section-title {
            font-size: 24px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        .subsection {
            margin-bottom: 30px;
        }

        .subsection-title {
            font-size: 20px;
            margin-bottom: 15px;
            color: var(--accent);
        }

        .subsection-content {
            font-size: 16px;
            margin-bottom: 20px;
        }

        .code-block {
            background-color: var(--code-bg);
            color: var(--code-color);
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 20px;
            position: relative;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .code-title {
            font-weight: 600;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .copy-btn {
            background: transparent;
            border: 1px solid var(--code-color);
            color: var(--code-color);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .copy-btn:hover {
            background-color: var(--code-color);
            color: var(--code-bg);
        }

        pre {
            margin: 0;
        }

        .explanation {
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .explanation h3 {
            margin-bottom: 10px;
            color: var(--accent);
        }

        .step {
            margin-bottom: 15px;
        }

        .step-number {
            display: inline-block;
            width: 24px;
            height: 24px;
            background-color: var(--primary);
            color: var(--secondary);
            text-align: center;
            line-height: 24px;
            border-radius: 50%;
            margin-right: 10px;
            font-weight: 600;
        }

        .practice-btn {
            display: inline-block;
            background-color: var(--primary);
            color: var(--secondary);
            padding: 12px 24px;
            border-radius: 4px;
            text-decoration: none;
            font-weight: 600;
            margin-top: 20px;
            transition: all 0.2s ease;
        }

        .practice-btn:hover {
            background-color: var(--accent);
        }

        .note {
            background-color: #f0f0f0;
            border-left: 4px solid var(--primary);
            padding: 15px;
            margin: 20px 0;
        }

        .note-title {
            font-weight: 600;
            margin-bottom: 5px;
        }

        /* Responsive Styles */
        .menu-toggle {
            display: none;
            background-color: var(--primary);
            color: var(--secondary);
            border: none;
            padding: 10px;
            cursor: pointer;
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            border-radius: 4px;
        }

        @media (max-width: 768px) {
            .menu-toggle {
                display: block;
            }

            .sidebar {
                position: fixed;
                left: -280px;
                top: 0;
                height: 100vh;
                z-index: 999;
            }

            .sidebar.active {
                left: 0;
            }

            .main-content {
                margin-left: 0;
                padding: 70px 20px 20px;
            }
        }

        /* Code Highlighting */
        .keyword {
            color: #ff79c6;
        }

        .string {
            color: #f1fa8c;
        }

        .comment {
            color: #6272a4;
        }

        .function {
            color: #50fa7b;
        }

        .number {
            color: #bd93f9;
        }

        .type {
            color: #8be9fd;
        }
    </style>
</head>
<body>
    <button class="menu-toggle" id="menuToggle">
        <i class="fas fa-bars"></i>
    </button>

    <div class="container">
        <!-- Sidebar Navigation -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h1>DSA Patterns</h1>
                <p>Master Data Structures & Algorithms</p>
            </div>

            <div class="nav-section">
                <div class="nav-title">Core Data Structures</div>
                <a class="nav-item active" data-section="arrays">
                    <i class="fas fa-layer-group"></i> Arrays
                </a>
                <div class="sub-nav active" id="arrays-subnav">
                    <a class="sub-nav-item active" data-subsection="array-basics">Basics</a>
                    <a class="sub-nav-item" data-subsection="array-problems">Problems</a>
                </div>

                <a class="nav-item" data-section="strings">
                    <i class="fas fa-font"></i> Strings
                </a>
                <div class="sub-nav" id="strings-subnav">
                    <a class="sub-nav-item" data-subsection="string-basics">Basics</a>
                    <a class="sub-nav-item" data-subsection="string-problems">Problems</a>
                </div>

                <a class="nav-item" data-section="stacks">
                    <i class="fas fa-stack"></i> Stacks
                </a>
                <div class="sub-nav" id="stacks-subnav">
                    <a class="sub-nav-item" data-subsection="stack-basics">Basics</a>
                    <a class="sub-nav-item" data-subsection="stack-problems">Problems</a>
                </div>

                <a class="nav-item" data-section="queues">
                    <i class="fas fa-stream"></i> Queues
                </a>
                <div class="sub-nav" id="queues-subnav">
                    <a class="sub-nav-item" data-subsection="queue-basics">Basics</a>
                    <a class="sub-nav-item" data-subsection="queue-problems">Problems</a>
                </div>

                <a class="nav-item" data-section="recursion">
                    <i class="fas fa-code-branch"></i> Recursion
                </a>
                <div class="sub-nav" id="recursion-subnav">
                    <a class="sub-nav-item" data-subsection="recursion-basics">Basics</a>
                    <a class="sub-nav-item" data-subsection="recursion-problems">Problems</a>
                </div>
            </div>

            <div class="nav-section">
                <div class="nav-title">Algorithms</div>
                <a class="nav-item" data-section="sorting">
                    <i class="fas fa-sort"></i> Sorting
                </a>
                <div class="sub-nav" id="sorting-subnav">
                    <a class="sub-nav-item" data-subsection="sorting-basics">Basics</a>
                    <a class="sub-nav-item" data-subsection="sorting-algorithms">Algorithms</a>
                </div>

                <a class="nav-item" data-section="searching">
                    <i class="fas fa-search"></i> Searching
                </a>
                <div class="sub-nav" id="searching-subnav">
                    <a class="sub-nav-item" data-subsection="searching-basics">Basics</a>
                    <a class="sub-nav-item" data-subsection="searching-algorithms">Algorithms</a>
                </div>
            </div>

            <div class="nav-section">
                <a href="https://twss-awe.pages.dev/dsa" class="practice-btn" target="_blank">
                    <i class="fas fa-external-link-alt"></i> Practice on DSA Platform
                </a>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="main-content">
            <!-- Arrays Section -->
            <div class="content-section active" id="arrays">
                <div class="content-header">
                    <h1>Arrays</h1>
                    <p>Learn the fundamentals of arrays and how to manipulate them efficiently in C++</p>
                </div>

                <!-- Array Basics Subsection -->
                <div class="subsection active" id="array-basics">
                    <h2 class="section-title">Array Basics</h2>

                    <div class="subsection-content">
                        <p>An array is a collection of items of the same data type stored at contiguous memory locations. It is one of the simplest data structures where each element can be accessed directly by its index.</p>
                    </div>

                    <div class="subsection">
                        <h3 class="subsection-title">What is an Array?</h3>
                        <div class="subsection-content">
                            <p>In C++, an array is a fixed-size sequence of elements of the same type. The size of an array must be a constant expression, and once defined, it cannot be changed.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">C++ Array Declaration</span>
                                <button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
using namespace std;

int main() {
    // Declaration of an integer array of size 5
    int arr[5];
    
    // Declaration and initialization
    int numbers[5] = {1, 2, 3, 4, 5};
    
    // Declaration with partial initialization (rest are 0)
    int partial[5] = {1, 2};  // {1, 2, 0, 0, 0}
    
    // Declaration without specifying size (size is inferred)
    int autoSized[] = {1, 2, 3, 4, 5, 6};
    
    return 0;
}">Copy</button>
                            </div>
                            <pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    // Declaration of an integer array of size 5
    int arr[5];
    
    // Declaration and initialization
    int numbers[5] = {1, 2, 3, 4, 5};
    
    // Declaration with partial initialization (rest are 0)
    int partial[5] = {1, 2};  // {1, 2, 0, 0, 0}
    
    // Declaration without specifying size (size is inferred)
    int autoSized[] = {1, 2, 3, 4, 5, 6};
    
    return 0;
}</code></pre>
                        </div>

                        <div class="explanation">
                            <h3>Explanation:</h3>
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Declaration:</strong> <code>int arr[5];</code> declares an array of 5 integers but doesn't initialize them.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Initialization:</strong> <code>int numbers[5] = {1, 2, 3, 4, 5};</code> declares and initializes an array with specific values.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Partial Initialization:</strong> When you initialize only some elements, the rest are set to 0.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">4</span>
                                <div>
                                    <strong>Auto-sizing:</strong> If you omit the size during initialization, the compiler determines it from the number of elements.
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3 class="subsection-title">Array Indexes</h3>
                        <div class="subsection-content">
                            <p>Array elements are accessed using zero-based indexing. The first element is at index 0, the second at index 1, and so on. The last element is at index (size-1).</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Accessing Array Elements</span>
                                <button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
using namespace std;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    
    // Accessing elements by index
    cout << &quot;First element: &quot; &lt;&lt; arr[0] &lt;&lt; endl;  // 10
    cout << &quot;Third element: &quot; &lt;&lt; arr[2] &lt;&lt; endl;  // 30
    cout << &quot;Last element: &quot; &lt;&lt; arr[4] &lt;&lt; endl;   // 50
    
    // Modifying elements
    arr[1] = 25;  // Change the second element from 20 to 25
    cout << &quot;Modified second element: &quot; &lt;&lt; arr[1] &lt;&lt; endl;  // 25
    
    // Array bounds (important to avoid going out of bounds)
    int size = sizeof(arr) / sizeof(arr[0]);
    cout &lt;&lt; &quot;Array size: &quot; &lt;&lt; size &lt;&lt; endl;  // 5
    
    return 0;
}">Copy</button>
                            </div>
                            <pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    
    // Accessing elements by index
    cout << "First element: " << arr[0] << endl;  // 10
    cout << "Third element: " << arr[2] << endl;  // 30
    cout << "Last element: " << arr[4] << endl;   // 50
    
    // Modifying elements
    arr[1] = 25;  // Change the second element from 20 to 25
    cout << "Modified second element: " << arr[1] << endl;  // 25
    
    // Array bounds (important to avoid going out of bounds)
    int size = sizeof(arr) / sizeof(arr[0]);
    cout << "Array size: " << size << endl;  // 5
    
    return 0;
}</code></pre>
                        </div>

                        <div class="explanation">
                            <h3>Explanation:</h3>
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Zero-based Indexing:</strong> Arrays in C++ use zero-based indexing, meaning the first element is at index 0.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Accessing Elements:</strong> Use the square bracket notation <code>arr[index]</code> to access or modify elements.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Array Bounds:</strong> Always ensure you're accessing valid indices (0 to size-1). Going out of bounds leads to undefined behavior.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">4</span>
                                <div>
                                    <strong>Calculating Size:</strong> Use <code>sizeof(arr) / sizeof(arr[0])</code> to calculate the number of elements in an array.
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3 class="subsection-title">Reverse Indexing</h3>
                        <div class="subsection-content">
                            <p>Sometimes it's useful to access array elements from the end. This is called reverse indexing, where the last element is accessed using <code>arr[size-1]</code>, the second last with <code>arr[size-2]</code>, and so on.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Reverse Indexing Example</span>
                                <button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
using namespace std;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int size = sizeof(arr) / sizeof(arr[0]);
    
    // Accessing elements from the end
    cout &lt;&lt; &quot;Last element: &quot; &lt;&lt; arr[size-1] &lt;&lt; endl;  // 50
    cout &lt;&lt; &quot;Second last element: &quot; &lt;&lt; arr[size-2] &lt;&lt; endl;  // 40
    cout &lt;&lt; &quot;Third last element: &quot; &lt;&lt; arr[size-3] &lt;&lt; endl;  // 30
    
    // Printing array in reverse order
    cout &lt;&lt; &quot;Array in reverse order: &quot;;
    for (int i = size-1; i >= 0; i--) {
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    return 0;
}">Copy</button>
                            </div>
                            <pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int size = sizeof(arr) / sizeof(arr[0]);
    
    // Accessing elements from the end
    cout << "Last element: " << arr[size-1] << endl;  // 50
    cout << "Second last element: " << arr[size-2] << endl;  // 40
    cout << "Third last element: " << arr[size-3] << endl;  // 30
    
    // Printing array in reverse order
    cout << "Array in reverse order: ";
    for (int i = size-1; i >= 0; i--) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    return 0;
}</code></pre>
                        </div>

                        <div class="explanation">
                            <h3>Explanation:</h3>
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Reverse Indexing:</strong> To access elements from the end, use <code>arr[size-index]</code> where index starts from 1.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Reverse Traversal:</strong> Loop from <code>size-1</code> down to <code>0</code> to traverse the array in reverse order.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Use Cases:</strong> Reverse indexing is useful for problems like palindrome checking, reversing an array, etc.
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3 class="subsection-title">Counting, Cumulating, and Frequency</h3>
                        <div class="subsection-content">
                            <p>Arrays are often used for counting occurrences, calculating cumulative sums, and determining frequencies of elements. These operations form the basis of many array-based algorithms.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Counting and Frequency Operations</span>
                                <button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;

int main() {
    int arr[] = {1, 2, 3, 2, 4, 1, 5, 2, 3, 1};
    int size = sizeof(arr) / sizeof(arr[0]);
    
    // Counting occurrences of a specific element
    int target = 2;
    int count = 0;
    for (int i = 0; i < size; i++) {
        if (arr[i] == target) {
            count++;
        }
    }
    cout &lt;&lt; &quot;Count of &quot; &lt;&lt; target &lt;&lt; &quot;: &quot; &lt;&lt; count &lt;&lt; endl;
    
    // Calculating frequency of all elements
    map&lt;int, int&gt; frequency;
    for (int i = 0; i < size; i++) {
        frequency[arr[i]]++;
    }
    
    cout &lt;&lt; &quot;Frequency of elements: &quot; &lt;&lt; endl;
    for (auto const& [key, val] : frequency) {
        cout &lt;&lt; key &lt;&lt; &quot;: &quot; &lt;&lt; val &lt;&lt; endl;
    }
    
    // Calculating cumulative sum
    vector&lt;int&gt; cumulative(size);
    cumulative[0] = arr[0];
    for (int i = 1; i < size; i++) {
        cumulative[i] = cumulative[i-1] + arr[i];
    }
    
    cout &lt;&lt; &quot;Cumulative sum: &quot; &lt;&lt; endl;
    for (int i = 0; i < size; i++) {
        cout &lt;&lt; cumulative[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    return 0;
}">Copy</button>
                            </div>
                            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;

int main() {
    int arr[] = {1, 2, 3, 2, 4, 1, 5, 2, 3, 1};
    int size = sizeof(arr) / sizeof(arr[0]);
    
    // Counting occurrences of a specific element
    int target = 2;
    int count = 0;
    for (int i = 0; i < size; i++) {
        if (arr[i] == target) {
            count++;
        }
    }
    cout << "Count of " << target << ": " << count << endl;
    
    // Calculating frequency of all elements
    map<int, int> frequency;
    for (int i = 0; i < size; i++) {
        frequency[arr[i]]++;
    }
    
    cout << "Frequency of elements: " << endl;
    for (auto const& [key, val] : frequency) {
        cout << key << ": " << val << endl;
    }
    
    // Calculating cumulative sum
    vector<int> cumulative(size);
    cumulative[0] = arr[0];
    for (int i = 1; i < size; i++) {
        cumulative[i] = cumulative[i-1] + arr[i];
    }
    
    cout << "Cumulative sum: " << endl;
    for (int i = 0; i < size; i++) {
        cout << cumulative[i] << " ";
    }
    cout << endl;
    
    return 0;
}</code></pre>
                        </div>

                        <div class="explanation">
                            <h3>Explanation:</h3>
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Counting:</strong> To count occurrences of a specific element, iterate through the array and increment a counter when the target is found.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Frequency Map:</strong> Use a map or hash table to store the frequency of each element in the array.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Cumulative Sum:</strong> Calculate the running sum of elements, where each element at index i is the sum of all elements from index 0 to i.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">4</span>
                                <div>
                                    <strong>Applications:</strong> These operations are used in problems like finding the most frequent element, subarray sum problems, etc.
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3 class="subsection-title">Iterating Through Arrays</h3>
                        <div class="subsection-content">
                            <p>Iterating through arrays is a fundamental operation. There are several ways to traverse arrays in C++, each with its own advantages and use cases.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Array Iteration Methods</span>
                                <button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int size = sizeof(arr) / sizeof(arr[0]);
    
    // Method 1: Traditional for loop with index
    cout &lt;&lt; &quot;Traditional for loop: &quot;;
    for (int i = 0; i < size; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    // Method 2: Range-based for loop (C++11 and later)
    cout &lt;&lt; &quot;Range-based for loop: &quot;;
    for (int element : arr) {
        cout &lt;&lt; element &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    // Method 3: Using pointers
    cout &lt;&lt; &quot;Using pointers: &quot;;
    int* ptr = arr;
    for (int i = 0; i < size; i++) {
        cout &lt;&lt; *(ptr + i) &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    // Method 4: Using iterators (for STL containers)
    vector&lt;int&gt; vec(arr, arr + size);
    cout &lt;&lt; &quot;Using iterators: &quot;;
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    return 0;
}">Copy</button>
                            </div>
                            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int size = sizeof(arr) / sizeof(arr[0]);
    
    // Method 1: Traditional for loop with index
    cout << "Traditional for loop: ";
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    // Method 2: Range-based for loop (C++11 and later)
    cout << "Range-based for loop: ";
    for (int element : arr) {
        cout << element << " ";
    }
    cout << endl;
    
    // Method 3: Using pointers
    cout << "Using pointers: ";
    int* ptr = arr;
    for (int i = 0; i < size; i++) {
        cout << *(ptr + i) << " ";
    }
    cout << endl;
    
    // Method 4: Using iterators (for STL containers)
    vector<int> vec(arr, arr + size);
    cout << "Using iterators: ";
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
    
    return 0;
}</code></pre>
                        </div>

                        <div class="explanation">
                            <h3>Explanation:</h3>
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Traditional For Loop:</strong> Uses an index variable to access each element. Useful when you need the index for operations.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Range-based For Loop:</strong> A cleaner syntax introduced in C++11. Automatically iterates through each element.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Pointer Arithmetic:</strong> Uses pointers and pointer arithmetic to access elements. Useful for understanding memory layout.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">4</span>
                                <div>
                                    <strong>Iterators:</strong> Used with STL containers like vectors. Provides a uniform way to traverse different container types.
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3 class="subsection-title">Vectors in C++</h3>
                        <div class="subsection-content">
                            <p>Vectors are dynamic arrays that can resize themselves automatically when an element is inserted or deleted. They are part of the C++ Standard Template Library (STL) and provide more flexibility than traditional arrays.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Vector Operations</span>
                                <button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    // Creating a vector
    vector&lt;int&gt; vec;
    
    // Adding elements to the vector
    vec.push_back(10);
    vec.push_back(20);
    vec.push_back(30);
    vec.push_back(40);
    vec.push_back(50);
    
    // Accessing elements
    cout &lt;&lt; &quot;First element: &quot; &lt;&lt; vec.front() &lt;&lt; endl;  // 10
    cout &lt;&lt; &quot;Last element: &quot; &lt;&lt; vec.back() &lt;&lt; endl;    // 50
    cout &lt;&lt; &quot;Element at index 2: &quot; &lt;&lt; vec[2] &lt;&lt; endl;   // 30
    
    // Vector size and capacity
    cout &lt;&lt; &quot;Size: &quot; &lt;&lt; vec.size() &lt;&lt; endl;        // 5
    cout &lt;&lt; &quot;Capacity: &quot; &lt;&lt; vec.capacity() &lt;&lt; endl; // >= 5
    
    // Iterating through a vector
    cout &lt;&lt; &quot;Vector elements: &quot;;
    for (int element : vec) {
        cout &lt;&lt; element &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    // Inserting an element at a specific position
    vec.insert(vec.begin() + 2, 25);  // Insert 25 at index 2
    
    // Removing an element
    vec.erase(vec.begin() + 3);  // Remove element at index 3
    
    // Checking if vector is empty
    if (!vec.empty()) {
        cout &lt;&lt; &quot;Vector is not empty&quot; &lt;&lt; endl;
    }
    
    // Resizing the vector
    vec.resize(10, 0);  // Resize to 10 elements, filling new positions with 0
    
    // Clearing the vector
    vec.clear();  // Removes all elements
    
    return 0;
}">Copy</button>
                            </div>
                            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    // Creating a vector
    vector<int> vec;
    
    // Adding elements to the vector
    vec.push_back(10);
    vec.push_back(20);
    vec.push_back(30);
    vec.push_back(40);
    vec.push_back(50);
    
    // Accessing elements
    cout << "First element: " << vec.front() << endl;  // 10
    cout << "Last element: " << vec.back() << endl;    // 50
    cout << "Element at index 2: " << vec[2] << endl;   // 30
    
    // Vector size and capacity
    cout << "Size: " << vec.size() << endl;        // 5
    cout << "Capacity: " << vec.capacity() << endl; // >= 5
    
    // Iterating through a vector
    cout << "Vector elements: ";
    for (int element : vec) {
        cout << element << " ";
    }
    cout << endl;
    
    // Inserting an element at a specific position
    vec.insert(vec.begin() + 2, 25);  // Insert 25 at index 2
    
    // Removing an element
    vec.erase(vec.begin() + 3);  // Remove element at index 3
    
    // Checking if vector is empty
    if (!vec.empty()) {
        cout << "Vector is not empty" << endl;
    }
    
    // Resizing the vector
    vec.resize(10, 0);  // Resize to 10 elements, filling new positions with 0
    
    // Clearing the vector
    vec.clear();  // Removes all elements
    
    return 0;
}</code></pre>
                        </div>

                        <div class="explanation">
                            <h3>Explanation:</h3>
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Creating Vectors:</strong> Use <code>vector&lt;type&gt; name;</code> to create an empty vector.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Adding Elements:</strong> Use <code>push_back()</code> to add elements to the end of the vector.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Accessing Elements:</strong> Use the subscript operator <code>[]</code> or methods like <code>front()</code> and <code>back()</code>.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">4</span>
                                <div>
                                    <strong>Size vs. Capacity:</strong> <code>size()</code> returns the number of elements, while <code>capacity()</code> returns the allocated space.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">5</span>
                                <div>
                                    <strong>Modifying Vectors:</strong> Use <code>insert()</code>, <code>erase()</code>, <code>resize()</code>, and <code>clear()</code> to modify the vector.
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3 class="subsection-title">2D Vectors</h3>
                        <div class="subsection-content">
                            <p>2D vectors are vectors of vectors, essentially creating a dynamic 2D array. They are useful for representing matrices, grids, and other tabular data structures.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">2D Vector Operations</span>
                                <button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    // Method 1: Creating a 2D vector with fixed dimensions
    vector&lt;vector&lt;int&gt;&gt; matrix(3, vector&lt;int&gt;(4, 0));  // 3x4 matrix initialized with 0
    
    // Method 2: Creating a 2D vector and adding rows dynamically
    vector&lt;vector&lt;int&gt;&gt; dynamicMatrix;
    
    // Adding rows to the dynamic matrix
    for (int i = 0; i < 3; i++) {
        vector&lt;int&gt; row;
        for (int j = 0; j < 4; j++) {
            row.push_back(i * 4 + j + 1);  // Fill with values 1, 2, 3, ...
        }
        dynamicMatrix.push_back(row);
    }
    
    // Accessing elements
    cout &lt;&lt; &quot;Element at (1,2): &quot; &lt;&lt; dynamicMatrix[1][2] &lt;&lt; endl;  // 7
    
    // Iterating through a 2D vector
    cout &lt;&lt; &quot;2D Vector elements: &quot; &lt;&lt; endl;
    for (int i = 0; i < dynamicMatrix.size(); i++) {
        for (int j = 0; j < dynamicMatrix[i].size(); j++) {
            cout &lt;&lt; dynamicMatrix[i][j] &lt;&lt; &quot;\t&quot;;
        }
        cout &lt;&lt; endl;
    }
    
    // Using range-based for loop (C++11 and later)
    cout &lt;&lt; &quot;2D Vector using range-based for loop: &quot; &lt;&lt; endl;
    for (const auto& row : dynamicMatrix) {
        for (const auto& element : row) {
            cout &lt;&lt; element &lt;&lt; &quot;\t&quot;;
        }
        cout &lt;&lt; endl;
    }
    
    // Modifying elements
    dynamicMatrix[0][0] = 100;  // Change the first element
    
    // Adding a new row
    vector&lt;int&gt; newRow = {13, 14, 15, 16};
    dynamicMatrix.push_back(newRow);
    
    // Removing a row
    dynamicMatrix.pop_back();  // Remove the last row
    
    return 0;
}">Copy</button>
                            </div>
                            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    // Method 1: Creating a 2D vector with fixed dimensions
    vector<vector<int>> matrix(3, vector<int>(4, 0));  // 3x4 matrix initialized with 0
    
    // Method 2: Creating a 2D vector and adding rows dynamically
    vector<vector<int>> dynamicMatrix;
    
    // Adding rows to the dynamic matrix
    for (int i = 0; i < 3; i++) {
        vector<int> row;
        for (int j = 0; j < 4; j++) {
            row.push_back(i * 4 + j + 1);  // Fill with values 1, 2, 3, ...
        }
        dynamicMatrix.push_back(row);
    }
    
    // Accessing elements
    cout << "Element at (1,2): " << dynamicMatrix[1][2] << endl;  // 7
    
    // Iterating through a 2D vector
    cout << "2D Vector elements: " << endl;
    for (int i = 0; i < dynamicMatrix.size(); i++) {
        for (int j = 0; j < dynamicMatrix[i].size(); j++) {
            cout << dynamicMatrix[i][j] << "\t";
        }
        cout << endl;
    }
    
    // Using range-based for loop (C++11 and later)
    cout << "2D Vector using range-based for loop: " << endl;
    for (const auto& row : dynamicMatrix) {
        for (const auto& element : row) {
            cout << element << "\t";
        }
        cout << endl;
    }
    
    // Modifying elements
    dynamicMatrix[0][0] = 100;  // Change the first element
    
    // Adding a new row
    vector<int> newRow = {13, 14, 15, 16};
    dynamicMatrix.push_back(newRow);
    
    // Removing a row
    dynamicMatrix.pop_back();  // Remove the last row
    
    return 0;
}</code></pre>
                        </div>

                        <div class="explanation">
                            <h3>Explanation:</h3>
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Creating 2D Vectors:</strong> Use <code>vector&lt;vector&lt;type&gt;&gt;</code> to create a 2D vector.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Initialization:</strong> You can initialize with specific dimensions or build it dynamically by adding rows.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Accessing Elements:</strong> Use double subscript notation <code>matrix[row][col]</code> to access elements.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">4</span>
                                <div>
                                    <strong>Iteration:</strong> Use nested loops to traverse a 2D vector. Range-based for loops provide cleaner syntax.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">5</span>
                                <div>
                                    <strong>Modifying:</strong> You can modify individual elements, add new rows with <code>push_back()</code>, or remove rows with <code>pop_back()</code>.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Array Problems Subsection -->
                <div class="subsection" id="array-problems">
                    <h2 class="section-title">Array Problems</h2>

                    <div class="subsection">
                        <h3 class="subsection-title">Problem 1: Two Sum</h3>
                        <div class="subsection-content">
                            <p>Given an array of integers and a target value, find two numbers in the array that sum up to the target value.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Two Sum Solution</span>
                                <button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
using namespace std;

// Function to find two numbers that sum up to the target
vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
    unordered_map&lt;int, int&gt; numMap;
    
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        
        // Check if the complement exists in the map
        if (numMap.find(complement) != numMap.end()) {
            return {numMap[complement], i};
        }
        
        // Add the current number to the map
        numMap[nums[i]] = i;
    }
    
    // If no solution is found
    return {};
}

int main() {
    vector&lt;int&gt; nums = {2, 7, 11, 15};
    int target = 9;
    
    vector&lt;int&gt; result = twoSum(nums, target);
    
    if (!result.empty()) {
        cout &lt;&lt; &quot;Indices: &quot; &lt;&lt; result[0] &lt;&lt; &quot;, &quot; &lt;&lt; result[1] &lt;&lt; endl;
        cout &lt;&lt; &quot;Values: &quot; &lt;&lt; nums[result[0]] &lt;&lt; &quot; + &quot; &lt;&lt; nums[result[1]] &lt;&lt; &quot; = &quot; &lt;&lt; target &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;No two sum solution found&quot; &lt;&lt; endl;
    }
    
    return 0;
}">Copy</button>
                            </div>
                            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
using namespace std;

// Function to find two numbers that sum up to the target
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> numMap;
    
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        
        // Check if the complement exists in the map
        if (numMap.find(complement) != numMap.end()) {
            return {numMap[complement], i};
        }
        
        // Add the current number to the map
        numMap[nums[i]] = i;
    }
    
    // If no solution is found
    return {};
}

int main() {
    vector<int> nums = {2, 7, 11, 15};
    int target = 9;
    
    vector<int> result = twoSum(nums, target);
    
    if (!result.empty()) {
        cout << "Indices: " << result[0] << ", " << result[1] << endl;
        cout << "Values: " << nums[result[0]] << " + " << nums[result[1]] << " = " << target << endl;
    } else {
        cout << "No two sum solution found" << endl;
    }
    
    return 0;
}</code></pre>
                        </div>

                        <div class="explanation">
                            <h3>Explanation:</h3>
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Problem Understanding:</strong> We need to find two numbers in an array that add up to a target value.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Hash Map Approach:</strong> We use a hash map to store numbers we've seen and their indices. For each number, we check if its complement (target - current number) exists in the map.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Time Complexity:</strong> O(n) - We iterate through the array once, and each hash map operation is O(1) on average.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">4</span>
                                <div>
                                    <strong>Space Complexity:</strong> O(n) - In the worst case, we might store all elements in the hash map.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">5</span>
                                <div>
                                    <strong>Edge Cases:</strong> Consider empty array, array with one element, and cases where no solution exists.
                                </div>
                            </div>
                        </div>

                        <div class="note">
                            <div class="note-title">Alternative Approach</div>
                            <p>A brute-force approach would be to use nested loops to check all pairs, which has a time complexity of O(n). The hash map approach is more efficient for large arrays.</p>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3 class="subsection-title">Problem 2: Reverse an Array</h3>
                        <div class="subsection-content">
                            <p>Write a function to reverse an array in-place, meaning you should modify the original array without using additional space for another array.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Reverse Array Solution</span>
                                <button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

// Function to reverse an array in-place
void reverseArray(vector&lt;int&gt;&amp; arr) {
    int left = 0;
    int right = arr.size() - 1;
    
    while (left < right) {
        // Swap elements at left and right indices
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
        
        // Move towards the center
        left++;
        right--;
    }
}

// Alternative approach using the STL reverse function
void reverseArraySTL(vector&lt;int&gt;&amp; arr) {
    reverse(arr.begin(), arr.end());
}

int main() {
    vector&lt;int&gt; arr = {1, 2, 3, 4, 5, 6, 7};
    
    cout &lt;&lt; &quot;Original array: &quot;;
    for (int num : arr) {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    // Reverse the array
    reverseArray(arr);
    
    cout &lt;&lt; &quot;Reversed array: &quot;;
    for (int num : arr) {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    // Reverse again using STL
    reverseArraySTL(arr);
    
    cout &lt;&lt; &quot;Reversed back using STL: &quot;;
    for (int num : arr) {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    return 0;
}">Copy</button>
                            </div>
                            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

// Function to reverse an array in-place
void reverseArray(vector<int>& arr) {
    int left = 0;
    int right = arr.size() - 1;
    
    while (left < right) {
        // Swap elements at left and right indices
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
        
        // Move towards the center
        left++;
        right--;
    }
}

// Alternative approach using the STL reverse function
void reverseArraySTL(vector<int>& arr) {
    reverse(arr.begin(), arr.end());
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7};
    
    cout << "Original array: ";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;
    
    // Reverse the array
    reverseArray(arr);
    
    cout << "Reversed array: ";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;
    
    // Reverse again using STL
    reverseArraySTL(arr);
    
    cout << "Reversed back using STL: ";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}</code></pre>
                        </div>

                        <div class="explanation">
                            <h3>Explanation:</h3>
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Two-Pointer Approach:</strong> We use two pointers, one at the beginning (left) and one at the end (right) of the array.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Swapping Elements:</strong> We swap the elements at the left and right pointers, then move both pointers towards the center.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Termination Condition:</strong> The loop continues until the left pointer is no longer less than the right pointer.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">4</span>
                                <div>
                                    <strong>Time Complexity:</strong> O(n/2) which simplifies to O(n) - We perform n/2 swaps.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">5</span>
                                <div>
                                    <strong>Space Complexity:</strong> O(1) - We only use a constant amount of extra space for the temporary variable and pointers.
                                </div>
                            </div>
                        </div>

                        <div class="note">
                            <div class="note-title">Alternative Approach</div>
                            <p>C++ STL provides a built-in <code>reverse()</code> function that can reverse a range of elements. This is often the preferred approach in production code as it's well-tested and optimized.</p>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3 class="subsection-title">Problem 3: Find Maximum Subarray</h3>
                        <div class="subsection-content">
                            <p>Given an integer array, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Kadane's Algorithm Solution</span>
                                <button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
using namespace std;

// Function to find the maximum subarray sum using Kadane's algorithm
int maxSubArray(vector&lt;int&gt;&amp; nums) {
    int maxSoFar = INT_MIN;  // Initialize with the smallest possible integer
    int maxEndingHere = 0;
    
    for (int i = 0; i < nums.size(); i++) {
        maxEndingHere = maxEndingHere + nums[i];
        
        // Update maxSoFar if current sum is greater
        if (maxSoFar < maxEndingHere) {
            maxSoFar = maxEndingHere;
        }
        
        // If maxEndingHere becomes negative, reset it to 0
        if (maxEndingHere < 0) {
            maxEndingHere = 0;
        }
    }
    
    return maxSoFar;
}

// Alternative approach that also returns the subarray indices
pair&lt;int, pair&lt;int, int&gt;&gt; maxSubArrayWithIndices(vector&lt;int&gt;&amp; nums) {
    int maxSoFar = INT_MIN;
    int maxEndingHere = 0;
    int start = 0;
    int end = 0;
    int s = 0;
    
    for (int i = 0; i < nums.size(); i++) {
        maxEndingHere += nums[i];
        
        if (maxSoFar < maxEndingHere) {
            maxSoFar = maxEndingHere;
            start = s;
            end = i;
        }
        
        if (maxEndingHere < 0) {
            maxEndingHere = 0;
            s = i + 1;
        }
    }
    
    return {maxSoFar, {start, end}};
}

int main() {
    vector&lt;int&gt; nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
    
    int result = maxSubArray(nums);
    cout &lt;&lt; &quot;Maximum subarray sum: &quot; &lt;&lt; result &lt;&lt; endl;
    
    auto resultWithIndices = maxSubArrayWithIndices(nums);
    cout &lt;&lt; &quot;Maximum subarray sum: &quot; &lt;&lt; resultWithIndices.first &lt;&lt; endl;
    cout &lt;&lt; &quot;Subarray indices: [&quot; &lt;&lt; resultWithIndices.second.first &lt;&lt; &quot;, &quot; &lt;&lt; resultWithIndices.second.second &lt;&lt; &quot;]&quot; &lt;&lt; endl;
    
    cout &lt;&lt; &quot;Subarray elements: &quot;;
    for (int i = resultWithIndices.second.first; i &lt;= resultWithIndices.second.second; i++) {
        cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    return 0;
}">Copy</button>
                            </div>
                            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
using namespace std;

// Function to find the maximum subarray sum using Kadane's algorithm
int maxSubArray(vector<int>& nums) {
    int maxSoFar = INT_MIN;  // Initialize with the smallest possible integer
    int maxEndingHere = 0;
    
    for (int i = 0; i < nums.size(); i++) {
        maxEndingHere = maxEndingHere + nums[i];
        
        // Update maxSoFar if current sum is greater
        if (maxSoFar < maxEndingHere) {
            maxSoFar = maxEndingHere;
        }
        
        // If maxEndingHere becomes negative, reset it to 0
        if (maxEndingHere < 0) {
            maxEndingHere = 0;
        }
    }
    
    return maxSoFar;
}

// Alternative approach that also returns the subarray indices
pair<int, pair<int, int>> maxSubArrayWithIndices(vector<int>& nums) {
    int maxSoFar = INT_MIN;
    int maxEndingHere = 0;
    int start = 0;
    int end = 0;
    int s = 0;
    
    for (int i = 0; i < nums.size(); i++) {
        maxEndingHere += nums[i];
        
        if (maxSoFar < maxEndingHere) {
            maxSoFar = maxEndingHere;
            start = s;
            end = i;
        }
        
        if (maxEndingHere < 0) {
            maxEndingHere = 0;
            s = i + 1;
        }
    }
    
    return {maxSoFar, {start, end}};
}

int main() {
    vector<int> nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
    
    int result = maxSubArray(nums);
    cout << "Maximum subarray sum: " << result << endl;
    
    auto resultWithIndices = maxSubArrayWithIndices(nums);
    cout << "Maximum subarray sum: " << resultWithIndices.first << endl;
    cout << "Subarray indices: [" << resultWithIndices.second.first << ", " << resultWithIndices.second.second << "]" << endl;
    
    cout << "Subarray elements: ";
    for (int i = resultWithIndices.second.first; i <= resultWithIndices.second.second; i++) {
        cout << nums[i] << " ";
    }
    cout << endl;
    
    return 0;
}</code></pre>
                        </div>

                        <div class="explanation">
                            <h3>Explanation:</h3>
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Kadane's Algorithm:</strong> We maintain two variables: <code>maxSoFar</code> to track the maximum sum found so far, and <code>maxEndingHere</code> to track the maximum sum of a subarray ending at the current position.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Updating Values:</strong> For each element, we add it to <code>maxEndingHere</code>. If this makes <code>maxEndingHere</code> negative, we reset it to 0, as a negative sum would decrease any future sum.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Tracking Maximum:</strong> We update <code>maxSoFar</code> whenever <code>maxEndingHere</code> exceeds it.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">4</span>
                                <div>
                                    <strong>Time Complexity:</strong> O(n) - We iterate through the array once.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">5</span>
                                <div>
                                    <strong>Space Complexity:</strong> O(1) - We only use a constant amount of extra space.
                                </div>
                            </div>
                        </div>

                        <div class="note">
                            <div class="note-title">Edge Cases</div>
                            <p>Consider arrays with all negative numbers. In such cases, the maximum subarray is the single largest (least negative) element. The implementation above handles this case correctly.</p>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3 class="subsection-title">Problem 4: Rotate Array</h3>
                        <div class="subsection-content">
                            <p>Given an array, rotate the array to the right by k steps, where k is non-negative.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">Rotate Array Solution</span>
                                <button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

// Method 1: Using reverse approach
void rotateArray(vector&lt;int&gt;&amp; nums, int k) {
    int n = nums.size();
    
    // Handle cases where k > n
    k = k % n;
    
    // If k is 0 or equal to n, no rotation is needed
    if (k == 0) return;
    
    // Reverse the entire array
    reverse(nums.begin(), nums.end());
    
    // Reverse the first k elements
    reverse(nums.begin(), nums.begin() + k);
    
    // Reverse the remaining elements
    reverse(nums.begin() + k, nums.end());
}

// Method 2: Using cyclic replacements
void rotateArrayCyclic(vector&lt;int&gt;&amp; nums, int k) {
    int n = nums.size();
    k = k % n;
    
    int count = 0;  // Count of elements moved
    
    for (int start = 0; count < n; start++) {
        int current = start;
        int prev = nums[start];
        
        do {
            int next = (current + k) % n;
            swap(nums[next], prev);
            current = next;
            count++;
        } while (start != current);
    }
}

// Method 3: Using extra space
void rotateArrayExtraSpace(vector&lt;int&gt;&amp; nums, int k) {
    int n = nums.size();
    k = k % n;
    
    vector&lt;int&gt; temp(n);
    
    for (int i = 0; i < n; i++) {
        temp[(i + k) % n] = nums[i];
    }
    
    nums = temp;
}

int main() {
    vector&lt;int&gt; nums = {1, 2, 3, 4, 5, 6, 7};
    int k = 3;
    
    cout &lt;&lt; &quot;Original array: &quot;;
    for (int num : nums) {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    // Rotate using reverse approach
    rotateArray(nums, k);
    
    cout &lt;&lt; &quot;Rotated array (reverse approach): &quot;;
    for (int num : nums) {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    // Reset array
    nums = {1, 2, 3, 4, 5, 6, 7};
    
    // Rotate using cyclic replacements
    rotateArrayCyclic(nums, k);
    
    cout &lt;&lt; &quot;Rotated array (cyclic approach): &quot;;
    for (int num : nums) {
        cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    
    return 0;
}">Copy</button>
                            </div>
                            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

// Method 1: Using reverse approach
void rotateArray(vector<int>& nums, int k) {
    int n = nums.size();
    
    // Handle cases where k > n
    k = k % n;
    
    // If k is 0 or equal to n, no rotation is needed
    if (k == 0) return;
    
    // Reverse the entire array
    reverse(nums.begin(), nums.end());
    
    // Reverse the first k elements
    reverse(nums.begin(), nums.begin() + k);
    
    // Reverse the remaining elements
    reverse(nums.begin() + k, nums.end());
}

// Method 2: Using cyclic replacements
void rotateArrayCyclic(vector<int>& nums, int k) {
    int n = nums.size();
    k = k % n;
    
    int count = 0;  // Count of elements moved
    
    for (int start = 0; count < n; start++) {
        int current = start;
        int prev = nums[start];
        
        do {
            int next = (current + k) % n;
            swap(nums[next], prev);
            current = next;
            count++;
        } while (start != current);
    }
}

// Method 3: Using extra space
void rotateArrayExtraSpace(vector<int>& nums, int k) {
    int n = nums.size();
    k = k % n;
    
    vector<int> temp(n);
    
    for (int i = 0; i < n; i++) {
        temp[(i + k) % n] = nums[i];
    }
    
    nums = temp;
}

int main() {
    vector<int> nums = {1, 2, 3, 4, 5, 6, 7};
    int k = 3;
    
    cout << "Original array: ";
    for (int num : nums) {
        cout << num << " ";
    }
    cout << endl;
    
    // Rotate using reverse approach
    rotateArray(nums, k);
    
    cout << "Rotated array (reverse approach): ";
    for (int num : nums) {
        cout << num << " ";
    }
    cout << endl;
    
    // Reset array
    nums = {1, 2, 3, 4, 5, 6, 7};
    
    // Rotate using cyclic replacements
    rotateArrayCyclic(nums, k);
    
    cout << "Rotated array (cyclic approach): ";
    for (int num : nums) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}</code></pre>
                        </div>

                        <div class="explanation">
                            <h3>Explanation:</h3>
                            <div class="step">
                                <span class="step-number">1</span>
                                <div>
                                    <strong>Reverse Approach:</strong> First reverse the entire array, then reverse the first k elements, and finally reverse the remaining elements. This results in the array being rotated to the right by k positions.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">2</span>
                                <div>
                                    <strong>Cyclic Replacements:</strong> Move elements one by one in a cycle. Start from the beginning and move each element to its correct position.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">3</span>
                                <div>
                                    <strong>Extra Space Approach:</strong> Create a temporary array of the same size and place each element in its correct position.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">4</span>
                                <div>
                                    <strong>Time Complexity:</strong> O(n) for all approaches - We need to move all elements.
                                </div>
                            </div>
                            <div class="step">
                                <span class="step-number">5</span>
                                <div>
                                    <strong>Space Complexity:</strong> O(1) for reverse and cyclic approaches, O(n) for the extra space approach.
                                </div>
                            </div>
                        </div>

                        <div class="note">
                            <div class="note-title">Handling Large k Values</div>
                            <p>When k is greater than the array size, rotating by k is equivalent to rotating by k % n (where n is the array size). This is handled in all the approaches above.</p>
                        </div>
                    </div>

                    <a href="https://twss-awe.pages.dev/dsa" class="practice-btn" target="_blank">
                        <i class="fas fa-external-link-alt"></i> Practice Array Problems
                    </a>
                </div>
            </div>

            <!-- Strings Section -->
            <div class="content-section" id="strings">
                <div class="content-header">
                    <h1>Strings</h1>
                    <p>Learn how to manipulate strings efficiently in C++ and solve common string problems</p>
                </div>

                <!-- String Basics Subsection -->
                <div class="subsection active" id="string-basics">
                    <h2 class="section-title">String Basics</h2>

                    <div class="subsection">
                        <h3 class="subsection-title">What is a String?</h3>
                        <div class="subsection-content">
                            <p>In C++, a string is a sequence of characters. The C++ standard library provides the <code>std::string</code> class, which is a powerful and flexible way to handle strings.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">String Declaration and Initialization</span>
                                <button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    // Different ways to declare and initialize strings
    
    // Empty string
    string str1;
    
    // String with initial value
    string str2(&quot;Hello&quot;);
    
    // String using string literal
    string str3 = &quot;World&quot;;
    
    // String using copy constructor
    string str4(str2);
    
    // String with repeated character
    string str5(5, 'A');  // &quot;AAAAA&quot;
    
    // String using substring
    string str6(&quot;Programming&quot;, 4);  // &quot;Prog&quot;
    
    // String from C-style string
    const char* cStr = &quot;C-String&quot;;
    string str7(cStr);
    
    // Output all strings
    cout &lt;&lt; &quot;str1: \&quot;&quot; &lt;&lt; str1 &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;str2: \&quot;&quot; &lt;&lt; str2 &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;str3: \&quot;&quot; &lt;&lt; str3 &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;str4: \&quot;&quot; &lt;&lt; str4 &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;str5: \&quot;&quot; &lt;&lt; str5 &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;str6: \&quot;&quot; &lt;&lt; str6 &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;str7: \&quot;&quot; &lt;&lt; str7 &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
    
    return 0;
}">Copy</button>
                            </div>
                            <pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    // Different ways to declare and initialize strings
    
    // Empty string
    string str1;
    
    // String with initial value
    string str2("Hello");
    
    // String using string literal
    string str3 = "World";
    
    // String using copy constructor
    string str4(str, top element: " &lt;&lt; s.top() &lt;&lt; endl;

// Popping all elements
while (!s.empty()) {
cout &lt;&lt; "Popping: " &lt;&lt; s.top() &lt;&lt; endl;
s.pop();
}

// Checking if the stack is empty again
if (s.empty()) {
cout &lt;&lt; "Stack is empty again" &lt;&lt; endl;
}

return 0;
}">Copy</button>
</div>
<pre><code>#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;

int main() {
// Creating a stack of integers
stack&lt;int&gt; s;

// Checking if the stack is empty
if (s.empty()) {
cout &lt;&lt; "Stack is empty" &lt;&lt; endl;
}

// Pushing elements onto the stack
s.push(10);
s.push(20);
s.push(30);

// Getting the size of the stack
cout &lt;&lt; "Stack size: " &lt;&lt; s.size() &lt;&lt; endl;

// Accessing the top element
cout &lt;&lt; "Top element: " &lt;&lt; s.top() &lt;&lt; endl;

// Popping elements from the stack
s.pop();
cout &lt;&lt; "After popping, top element: " &lt;&lt; s.top() &lt;&lt; endl;

// Popping all elements
while (!s.empty()) {
cout &lt;&lt; "Popping: " &lt;&lt; s.top() &lt;&lt; endl;
s.pop();
}

// Checking if the stack is empty again
if (s.empty()) {
cout &lt;&lt; "Stack is empty again" &lt;&lt; endl;
}

return 0;
}</code></pre>
</div>

<div class="explanation">
<h3>Explanation:</h3>
<div class="step">
<span class="step-number">1</span>
<div>
<strong>Stack Creation:</strong> <code>stack&lt;type&gt; name;</code> creates an empty stack. The type can be any data type, like <code>int</code>, <code>string</code>, or even a custom object.
</div>
</div>
<div class="step">
<span class="step-number">2</span>
<div>
<strong>push(element):</strong> Adds an element to the top of the stack.
</div>
</div>
<div class="step">
<span class="step-number">3</span>
<div>
<strong>top():</strong> Returns a reference to the top element of the stack. This is the last element that was pushed. It does not remove the element.
</div>
</div>
<div class="step">
<span class="step-number">4</span>
<div>
<strong>pop():</strong> Removes the top element from the stack. It does not return the element.
</div>
</div>
<div class="step">
<span class="step-number">5</span>
<div>
<strong>empty():</strong> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.
</div>
</div>
<div class="step">
<span class="step-number">6</span>
<div>
<strong>size():</strong> Returns the number of elements in the stack.
</div>
</div>
</div>
</div>

<div class="subsection">
<h3 class="subsection-title">Implementing a Stack from Scratch</h3>
<div class="subsection-content">
<p>While C++ provides a ready-to-use stack, it's instructive to implement one yourself to understand how it works internally. We'll use a vector as the underlying container.</p>
</div>

<div class="code-block">
<div class="code-header">
<span class="code-title">Custom Stack Implementation</span>
<button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
using namespace std;

template &lt;typename T&gt;
class CustomStack {
private:
vector&lt;T&gt; elements;

public:
// Push an element onto the stack
void push(const T& value) {
elements.push_back(value);
}

// Remove the top element from the stack
void pop() {
if (empty()) {
throw out_of_range("Stack&lt;T&gt;::pop(): empty stack");
}
elements.pop_back();
}

// Return the top element of the stack
T& top() {
if (empty()) {
throw out_of_range("Stack&lt;T&gt;::top(): empty stack");
}
return elements.back();
}

// Return the top element of the stack (const version)
const T& top() const {
if (empty()) {
throw out_of_range("Stack&lt;T&gt;::top(): empty stack");
}
return elements.back();
}

// Check if the stack is empty
bool empty() const {
return elements.empty();
}

// Return the number of elements in the stack
size_t size() const {
return elements.size();
}
};

int main() {
CustomStack&lt;int&gt; s;

// Pushing elements
s.push(100);
s.push(200);
s.push(300);

cout &lt;&lt; "Top element: " &lt;&lt; s.top() &lt;&lt; endl;
cout &lt;&lt; "Stack size: " &lt;&lt; s.size() &lt;&lt; endl;

// Popping an element
s.pop();
cout &lt;&lt; "After popping, top element: " &lt;&lt; s.top() &lt;&lt; endl;

return 0;
}">Copy</button>
</div>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;
using namespace std;

template &lt;typename T&gt;
class CustomStack {
private:
vector&lt;T&gt; elements;

public:
// Push an element onto the stack
void push(const T& value) {
elements.push_back(value);
}

// Remove the top element from the stack
void pop() {
if (empty()) {
throw out_of_range("Stack&lt;T&gt;::pop(): empty stack");
}
elements.pop_back();
}

// Return the top element of the stack
T& top() {
if (empty()) {
throw out_of_range("Stack&lt;T&gt;::top(): empty stack");
}
return elements.back();
}

// Return the top element of the stack (const version)
const T& top() const {
if (empty()) {
throw out_of_range("Stack&lt;T&gt;::top(): empty stack");
}
return elements.back();
}

// Check if the stack is empty
bool empty() const {
return elements.empty();
}

// Return the number of elements in the stack
size_t size() const {
return elements.size();
}
};

int main() {
CustomStack&lt;int&gt; s;

// Pushing elements
s.push(100);
s.push(200);
s.push(300);

cout &lt;&lt; "Top element: " &lt;&lt; s.top() &lt;&lt; endl;
cout &lt;&lt; "Stack size: " &lt;&lt; s.size() &lt;&lt; endl;

// Popping an element
s.pop();
cout &lt;&lt; "After popping, top element: " &lt;&lt; s.top() &lt;&lt; endl;

return 0;
}</code></pre>
</div>

<div class="explanation">
<h3>Explanation:</h3>
<div class="step">
<span class="step-number">1</span>
<div>
<strong>Template Class:</strong> We use a template <code>&lt;typename T&gt;</code> to make our stack work with any data type.
</div>
</div>
<div class="step">
<span class="step-number">2</span>
<div>
<strong>Underlying Container:</strong> A <code>vector&lt;T&gt;</code> is used to store the elements. Vectors are dynamic arrays that can grow and shrink, making them suitable for a stack implementation.
</div>
</div>
<div class="step">
<span class="step-number">3</span>
<div>
<strong>push():</strong> We use <code>vector::push_back()</code> to add an element to the end of the vector, which corresponds to the top of our stack.
</div>
</div>
<div class="step">
<span class="step-number">4</span>
<div>
<strong>pop():</strong> We use <code>vector::pop_back()</code> to remove the last element from the vector. We also check if the stack is empty before popping to avoid errors.
</div>
</div>
<div class="step">
<span class="step-number">5</span>
<div>
<strong>top():</strong> We use <code>vector::back()</code> to access the last element of the vector. Again, we check if the stack is empty.
</div>
</div>
<div class="step">
<span class="step-number">6</span>
<div>
<strong>empty() and size():</strong> These methods simply delegate to the corresponding methods of the vector.
</div>
</div>
</div>
</div>
</div>

<!-- Stack Problems Subsection -->
<div class="subsection" id="stack-problems">
<h2 class="section-title">Stack Problems</h2>

<div class="subsection">
<h3 class="subsection-title">Problem 1: Valid Parentheses</h3>
<div class="subsection-content">
<p>Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. A string is valid if open brackets are closed by the same type of brackets and in the correct order.</p>
</div>

<div class="code-block">
<div class="code-header">
<span class="code-title">Valid Parentheses Solution</span>
<button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;unordered_map&gt;
using namespace std;

bool isValid(string s) {
stack&lt;char&gt; st;

// Map closing brackets to their corresponding opening brackets
unordered_map&lt;char, char&gt; brackets = {
{')', '('},
{'}', '{'},
{']', '['}
};

for (char c : s) {
// If it's an opening bracket, push onto the stack
if (brackets.find(c) == brackets.end()) {
st.push(c);
}
// If it's a closing bracket
else {
// Check if the stack is empty or the top doesn't match
if (st.empty() || st.top() != brackets[c]) {
return false;
}
// Pop the matching opening bracket
st.pop();
}
}

// If the stack is empty, all brackets were matched correctly
return st.empty();
}

int main() {
string s1 = "()";
string s2 = "()[]{}";
string s3 = "(]";
string s4 = "([)]";
string s5 = "{[]}";

cout &lt;&lt; s1 &lt;&lt; " is " &lt;&lt; (isValid(s1) ? "valid" : "invalid") &lt;&lt; endl;
cout &lt;&lt; s2 &lt;&lt; " is " &lt;&lt; (isValid(s2) ? "valid" : "invalid") &lt;&lt; endl;
cout &lt;&lt; s3 &lt;&lt; " is " &lt;&lt; (isValid(s3) ? "valid" : "invalid") &lt;&lt; endl;
cout &lt;&lt; s4 &lt;&lt; " is " &lt;&lt; (isValid(s4) ? "valid" : "invalid") &lt;&lt; endl;
cout &lt;&lt; s5 &lt;&lt; " is " &lt;&lt; (isValid(s5) ? "valid" : "invalid") &lt;&lt; endl;

return 0;
}">Copy</button>
</div>
<pre><code>#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;unordered_map&gt;
using namespace std;

bool isValid(string s) {
stack&lt;char&gt; st;

// Map closing brackets to their corresponding opening brackets
unordered_map&lt;char, char&gt; brackets = {
{')', '('},
{'}', '{'},
{']', '['}
};

for (char c : s) {
// If it's an opening bracket, push onto the stack
if (brackets.find(c) == brackets.end()) {
st.push(c);
}
// If it's a closing bracket
else {
// Check if the stack is empty or the top doesn't match
if (st.empty() || st.top() != brackets[c]) {
return false;
}
// Pop the matching opening bracket
st.pop();
}
}

// If the stack is empty, all brackets were matched correctly
return st.empty();
}

int main() {
string s1 = "()";
string s2 = "()[]{}";
string s3 = "(]";
string s4 = "([)]";
string s5 = "{[]}";

cout &lt;&lt; s1 &lt;&lt; " is " &lt;&lt; (isValid(s1) ? "valid" : "invalid") &lt;&lt; endl;
cout &lt;&lt; s2 &lt;&lt; " is " &lt;&lt; (isValid(s2) ? "valid" : "invalid") &lt;&lt; endl;
cout &lt;&lt; s3 &lt;&lt; " is " &lt;&lt; (isValid(s3) ? "valid" : "invalid") &lt;&lt; endl;
cout &lt;&lt; s4 &lt;&lt; " is " &lt;&lt; (isValid(s4) ? "valid" : "invalid") &lt;&lt; endl;
cout &lt;&lt; s5 &lt;&lt; " is " &lt;&lt; (isValid(s5) ? "valid" : "invalid") &lt;&lt; endl;

return 0;
}</code></pre>
</div>

<div class="explanation">
<h3>Explanation:</h3>
<div class="step">
<span class="step-number">1</span>
<div>
<strong>Stack Usage:</strong> We use a stack to keep track of the opening brackets we've seen so far.
</div>
</div>
<div class="step">
<span class="step-number">2</span>
<div>
<strong>Opening Brackets:</strong> When we encounter an opening bracket, we push it onto the stack.
</div>
</div>
<div class="step">
<span class="step-number">3</span>
<div>
<strong>Closing Brackets:</strong> When we encounter a closing bracket, we check if the stack is empty or if the top of the stack is the corresponding opening bracket. If not, the string is invalid.
</div>
</div>
<div class="step">
<span class="step-number">4</span>
<div>
<strong>Final Check:</strong> After processing all characters, if the stack is empty, it means all opening brackets were matched with a corresponding closing bracket, and the string is valid.
</div>
</div>
<div class="step">
<span class="step-number">5</span>
<div>
<strong>Time Complexity:</strong> O(n) - We iterate through the string once.
</div>
</div>
<div class="step">
<span class="step-number">6</span>
<div>
<strong>Space Complexity:</strong> O(n) - In the worst case (e.g., "(((("), the stack will contain all opening brackets.
</div>
</div>
</div>
</div>

<a href="https://twss-awe.pages.dev/dsa" class="practice-btn" target="_blank">
<i class="fas fa-external-link-alt"></i> Practice Stack Problems
</a>
</div>
</div>

<!-- Queues Section -->
<div class="content-section" id="queues">
<div class="content-header">
<h1>Queues</h1>
<p>Learn about the queue data structure and its applications in solving problems</p>
</div>

<!-- Queue Basics Subsection -->
<div class="subsection active" id="queue-basics">
<h2 class="section-title">Queue Basics</h2>

<div class="subsection">
<h3 class="subsection-title">What is a Queue?</h3>
<div class="subsection-content">
<p>A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. The first element added to the queue is the first one to be removed. Think of it like a queue of people at a ticket counter: the first person in line gets served first.</p>
</div>

<div class="code-block">
<div class="code-header">
<span class="code-title">Queue Declaration and Operations</span>
<button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

int main() {
// Creating a queue of integers
queue&lt;int&gt; q;

// Checking if the queue is empty
if (q.empty()) {
cout &lt;&lt; "Queue is empty" &lt;&lt; endl;
}

// Enqueue (add) elements to the back of the queue
q.push(10);
q.push(20);
q.push(30);

// Getting the size of the queue
cout &lt;&lt; "Queue size: " &lt;&lt; q.size() &lt;&lt; endl;

// Accessing the front element
cout &lt;&lt; "Front element: " &lt;&lt; q.front() &lt;&lt; endl;

// Accessing the back element
cout &lt;&lt; "Back element: " &lt;&lt; q.back() &lt;&lt; endl;

// Dequeue (remove) an element from the front of the queue
q.pop();
cout &lt;&lt; "After popping, front element: " &lt;&lt; q.front() &lt;&lt; endl;

// Dequeue all elements
while (!q.empty()) {
cout &lt;&lt; "Popping: " &lt;&lt; q.front() &lt;&lt; endl;
q.pop();
}

// Checking if the queue is empty again
if (q.empty()) {
cout &lt;&lt; "Queue is empty again" &lt;&lt; endl;
}

return 0;
}">Copy</button>
</div>
<pre><code>#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

int main() {
// Creating a queue of integers
queue&lt;int&gt; q;

// Checking if the queue is empty
if (q.empty()) {
cout &lt;&lt; "Queue is empty" &lt;&lt; endl;
}

// Enqueue (add) elements to the back of the queue
q.push(10);
q.push(20);
q.push(30);

// Getting the size of the queue
cout &lt;&lt; "Queue size: " &lt;&lt; q.size() &lt;&lt; endl;

// Accessing the front element
cout &lt;&lt; "Front element: " &lt;&lt; q.front() &lt;&lt; endl;

// Accessing the back element
cout &lt;&lt; "Back element: " &lt;&lt; q.back() &lt;&lt; endl;

// Dequeue (remove) an element from the front of the queue
q.pop();
cout &lt;&lt; "After popping, front element: " &lt;&lt; q.front() &lt;&lt; endl;

// Dequeue all elements
while (!q.empty()) {
cout &lt;&lt; "Popping: " &lt;&lt; q.front() &lt;&lt; endl;
q.pop();
}

// Checking if the queue is empty again
if (q.empty()) {
cout &lt;&lt; "Queue is empty again" &lt;&lt; endl;
}

return 0;
}</code></pre>
</div>

<div class="explanation">
<h3>Explanation:</h3>
<div class="step">
<span class="step-number">1</span>
<div>
<strong>Queue Creation:</strong> <code>queue&lt;type&gt; name;</code> creates an empty queue.
</div>
</div>
<div class="step">
<span class="step-number">2</span>
<div>
<strong>push(element):</strong> Adds an element to the back (end) of the queue.
</div>
</div>
<div class="step">
<span class="step-number">3</span>
<div>
<strong>front():</strong> Returns a reference to the front element of the queue. This is the first element that was pushed.
</div>
</div>
<div class="step">
<span class="step-number">4</span>
<div>
<strong>back():</strong> Returns a reference to the back element of the queue. This is the last element that was pushed.
</div>
</div>
<div class="step">
<span class="step-number">5</span>
<div>
<strong>pop():</strong> Removes the front element from the queue.
</div>
</div>
<div class="step">
<span class="step-number">6</span>
<div>
<strong>empty() and size():</strong> These functions work just like they do for stacks, checking if the queue is empty and returning its size, respectively.
</div>
</div>
</div>
</div>
</div>

<!-- Queue Problems Subsection -->
<div class="subsection" id="queue-problems">
<h2 class="section-title">Queue Problems</h2>

<div class="subsection">
<h3 class="subsection-title">Problem 1: Implement Stack using Queues</h3>
<div class="subsection-content">
<p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).</p>
</div>

<div class="code-block">
<div class="code-header">
<span class="code-title">Stack using Queues Solution</span>
<button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

class MyStack {
private:
queue&lt;int&gt; q1, q2;

public:
MyStack() {}

// Push element x onto stack
void push(int x) {
// Push to the non-empty queue
if (!q1.empty()) {
q1.push(x);
} else {
q2.push(x);
}
}

// Removes the element on top of the stack and returns that element
int pop() {
if (empty()) {
throw runtime_error("Stack is empty");
}

int topElement;
// Move all elements except the last one from the non-empty queue to the empty one
if (!q1.empty()) {
while (q1.size() > 1) {
q2.push(q1.front());
q1.pop();
}
topElement = q1.front();
q1.pop();
} else {
while (q2.size() > 1) {
q1.push(q2.front());
q2.pop();
}
topElement = q2.front();
q2.pop();
}

return topElement;
}

// Get the top element
int top() {
if (empty()) {
throw runtime_error("Stack is empty");
}

int topElement;
// Move all elements except the last one from the non-empty queue to the empty one
if (!q1.empty()) {
while (q1.size() > 1) {
q2.push(q1.front());
q1.pop();
}
topElement = q1.front();
q2.push(q1.front()); // Move it back to maintain the stack state
q1.pop();
} else {
while (q2.size() > 1) {
q1.push(q2.front());
q2.pop();
}
topElement = q2.front();
q1.push(q2.front()); // Move it back to maintain the stack state
q2.pop();
}

return topElement;
}

// Returns whether the stack is empty
bool empty() const {
return q1.empty() && q2.empty();
}
};

int main() {
MyStack s;
s.push(1);
s.push(2);
s.push(3);

cout &lt;&lt; "Top element: " &lt;&lt; s.top() &lt;&lt; endl; // Should be 3
s.pop();
cout &lt;&lt; "Top element after pop: " &lt;&lt; s.top() &lt;&lt; endl; // Should be 2

return 0;
}">Copy</button>
</div>
<pre><code>#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

class MyStack {
private:
queue&lt;int&gt; q1, q2;

public:
MyStack() {}

// Push element x onto stack
void push(int x) {
// Push to the non-empty queue
if (!q1.empty()) {
q1.push(x);
} else {
q2.push(x);
}
}

// Removes the element on top of the stack and returns that element
int pop() {
if (empty()) {
throw runtime_error("Stack is empty");
}

int topElement;
// Move all elements except the last one from the non-empty queue to the empty one
if (!q1.empty()) {
while (q1.size() > 1) {
q2.push(q1.front());
q1.pop();
}
topElement = q1.front();
q1.pop();
} else {
while (q2.size() > 1) {
q1.push(q2.front());
q2.pop();
}
topElement = q2.front();
q2.pop();
}

return topElement;
}

// Get the top element
int top() {
if (empty()) {
throw runtime_error("Stack is empty");
}

int topElement;
// Move all elements except the last one from the non-empty queue to the empty one
if (!q1.empty()) {
while (q1.size() > 1) {
q2.push(q1.front());
q1.pop();
}
topElement = q1.front();
q2.push(q1.front()); // Move it back to maintain the stack state
q1.pop();
} else {
while (q2.size() > 1) {
q1.push(q2.front());
q2.pop();
}
topElement = q2.front();
q1.push(q2.front()); // Move it back to maintain the stack state
q2.pop();
}

return topElement;
}

// Returns whether the stack is empty
bool empty() const {
return q1.empty() && q2.empty();
}
};

int main() {
MyStack s;
s.push(1);
s.push(2);
s.push(3);

cout &lt;&lt; "Top element: " &lt;&lt; s.top() &lt;&lt; endl; // Should be 3
s.pop();
cout &lt;&lt; "Top element after pop: " &lt;&lt; s.top() &lt;&lt; endl; // Should be 2

return 0;
}</code></pre>
</div>

<div class="explanation">
<h3>Explanation:</h3>
<div class="step">
<span class="step-number">1</span>
<div>
<strong>Two Queues:</strong> We use two queues, <code>q1</code> and <code>q2</code>. At any time, one of them will be empty.
</div>
</div>
<div class="step">
<span class="step-number">2</span>
<div>
<strong>push(x):</strong> We always push the new element to the non-empty queue. This ensures the newest element is at the back of that queue.
</div>
</div>
<div class="step">
<span class="step-number">3</span>
<div>
<strong>pop():</strong> To pop, we identify the non-empty queue. We then dequeue all elements except the last one and enqueue them into the empty queue. The last element remaining in the original queue is the top of our "stack," so we dequeue and return it.
</div>
</div>
<div class="step">
<span class="step-number">4</span>
<div>
<strong>top():</strong> This is similar to <code>pop()</code>, but after finding the top element, we enqueue it back into the other queue to preserve the stack's state.
</div>
</div>
<div class="step">
<span class="step-number">5</span>
<div>
<strong>Time Complexity:</strong> <code>push</code> is O(1). <code>pop</code> and <code>top</code> are O(n) because we might need to move n-1 elements.
</div>
</div>
</div>
</div>

<a href="https://twss-awe.pages.dev/dsa" class="practice-btn" target="_blank">
<i class="fas fa-external-link-alt"></i> Practice Queue Problems
</a>
</div>
</div>

<!-- ... (Similar sections for Recursion, Sorting, Searching would follow) ... -->
<!-- Due to length constraints, I'll provide a summary of what the remaining sections would contain. -->

<!-- Recursion Section -->
<div class="content-section" id="recursion">
<div class="content-header">
<h1>Recursion</h1>
<p>Master the concept of recursion and its applications in problem-solving</p>
</div>
<div class="subsection active" id="recursion-basics">
<h2 class="section-title">Recursion Basics</h2>
<div class="subsection">
<h3 class="subsection-title">What is Recursion?</h3>
<div class="subsection-content">
<p>Recursion is a programming technique where a function calls itself directly or indirectly. It's a powerful tool for solving problems that can be broken down into smaller, similar subproblems. A recursive function typically has two main parts: a base case and a recursive step.</p>
</div>
<div class="code-block">
<div class="code-header">
<span class="code-title">Factorial using Recursion</span>
<button class="copy-btn" data-clipboard-text="#include &lt;iostream&gt;
using namespace std;

// Recursive function to calculate factorial
int factorial(int n) {
// Base case: factorial of 0 is 1
if (n == 0) {
return 1;
}
// Recursive step: n * factorial(n-1)
else {
return n * factorial(n - 1);
}
}

int main() {
int num = 5;
cout &lt;&lt; "Factorial of " &lt;&lt; num &lt;&lt; " is " &lt;&lt; factorial(num) &lt;&lt; endl;
return 0;
}">Copy</button>
</div>
<pre><code>#include &lt;iostream&gt;
using namespace std;

// Recursive function to calculate factorial
int factorial(int n) {
// Base case: factorial of 0 is 1
if (n == 0) {
return 1;
}
// Recursive step: n * factorial(n-1)
else {
return n * factorial(n - 1);
}
}

int main() {
int num = 5;
cout &lt;&lt; "Factorial of " &lt;&lt; num &lt;&lt; " is " &lt;&lt; factorial(num) &lt;&lt; endl;
return 0;
}</code></pre>
</div>
<div class="explanation">
<h3>Explanation:</h3>
<div class="step">
<span class="step-number">1</span>
<div>
<strong>Base Case:</strong> The condition that stops the recursion. For factorial, it's when <code>n</code> becomes 0. Without a base case, you'd have infinite recursion.
</div>
</div>
<div class="step">
<span class="step-number">2</span>
<div>
<strong>Recursive Step:</strong> The part of the function that calls itself with a modified argument, moving closer to the base case. Here, it's <code>factorial(n - 1)</code>.
</div>
</div>
</div>
</div>
</div>
<div class="subsection" id="recursion-problems">
<h2 class="section-title">Recursion Problems</h2>
<div class="subsection">
<h3 class="subsection-title">Problem 1: Fibonacci Sequence</h3>
<div class="subsection-content">
<p>The Fibonacci numbers are a sequence of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. Write a recursive function to compute the Nth Fibonacci number.</p>
</div>
<!-- ... Code and explanation for Fibonacci ... -->
</div>
<a href="https://twss-awe.pages.dev/dsa" class="practice-btn" target="_blank">
<i class="fas fa-external-link-alt"></i> Practice Recursion Problems
</a>
</div>
</div>

<!-- Sorting Section -->
<div class="content-section" id="sorting">
<div class="content-header">
<h1>Sorting</h1>
<p>Explore various sorting algorithms and their efficiency</p>
</div>
<div class="subsection active" id="sorting-basics">
<h2 class="section-title">Sorting Basics</h2>
<div class="subsection">
<h3 class="subsection-title">What is Sorting?</h3>
<div class="subsection-content">
<p>Sorting is the process of arranging items in a certain order (e.g., ascending or descending). It's a fundamental operation in computer science with numerous applications.</p>
</div>
</div>
</div>
<div class="subsection" id="sorting-algorithms">
<h2 class="section-title">Sorting Algorithms</h2>
<div class="subsection">
<h3 class="subsection-title">Algorithm 1: Bubble Sort</h3>
<div class="subsection-content">
<p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.</p>
</div>
<!-- ... Code and explanation for Bubble Sort ... -->
</div>
<a href="https://twss-awe.pages.dev/dsa" class="practice-btn" target="_blank">
<i class="fas fa-external-link-alt"></i> Practice Sorting Algorithms
</a>
</div>
</div>

<!-- Searching Section -->
<div class="content-section" id="searching">
<div class="content-header">
<h1>Searching</h1>
<p>Learn efficient techniques for finding elements in a data structure</p>
</div>
<div class="subsection active" id="searching-basics">
<h2 class="section-title">Searching Basics</h2>
<div class="subsection">
<h3 class="subsection-title">What is Searching?</h3>
<div class="subsection-content">
<p>Searching is the process of finding a specific item in a collection of items. The efficiency of a search algorithm depends on the data structure being searched.</p>
</div>
</div>
</div>
<div class="subsection" id="searching-algorithms">
<h2 class="section-title">Searching Algorithms</h2>
<div class="subsection">
<h3 class="subsection-title">Algorithm 1: Binary Search</h3>
<div class="subsection-content">
<p>Binary Search is a highly efficient searching algorithm that works on the principle of divide and conquer. It requires the array to be sorted.</p>
</div>
<!-- ... Code and explanation for Binary Search ... -->
</div>
<a href="https://twss-awe.pages.dev/dsa" class="practice-btn" target="_blank">
<i class="fas fa-external-link-alt"></i> Practice Searching Algorithms
</a>
</div>
</div>
</div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
// Sidebar navigation
const navItems = document.querySelectorAll('.nav-item');
const subNavs = document.querySelectorAll('.sub-nav');
const contentSections = document.querySelectorAll('.content-section');
const subSections = document.querySelectorAll('.subsection');
const menuToggle = document.getElementById('menuToggle');
const sidebar = document.getElementById('sidebar');

menuToggle.addEventListener('click', () => {
sidebar.classList.toggle('active');
});

navItems.forEach(item => {
item.addEventListener('click', () => {
const sectionId = item.dataset.section;
const subNavId = sectionId + '-subnav';

// Update active nav item
navItems.forEach(nav => nav.classList.remove('active'));
item.classList.add('active');

// Update active sub-nav
subNavs.forEach(nav => nav.classList.remove('active'));
document.getElementById(subNavId).classList.add('active');

// Update active content section
contentSections.forEach(section => section.classList.remove('active'));
document.getElementById(sectionId).classList.add('active');

// Show the first subsection of the new section
const firstSubsection = document.querySelector(`#${sectionId} .subsection`);
if(firstSubsection) {
subSections.forEach(sub => sub.classList.remove('active'));
firstSubsection.classList.add('active');
}
});
});

// Sub-nav navigation
const subNavItems = document.querySelectorAll('.sub-nav-item');
subNavItems.forEach(item => {
item.addEventListener('click', () => {
const subsectionId = item.dataset.subsection;

// Update active sub-nav item
subNavItems.forEach(nav => nav.classList.remove('active'));
item.classList.add('active');

// Update active subsection
subSections.forEach(section => section.classList.remove('active'));
document.getElementById(subsectionId).classList.add('active');
});
});

// Copy code functionality
const copyButtons = document.querySelectorAll('.copy-btn');
copyButtons.forEach(button => {
button.addEventListener('click', () => {
const codeToCopy = button.getAttribute('data-clipboard-text');
navigator.clipboard.writeText(codeToCopy).then(() => {
const originalText = button.textContent;
button.textContent = 'Copied!';
setTimeout(() => {
button.textContent = originalText;
}, 2000);
}).catch(err => {
console.error('Failed to copy: ', err);
});
});
});
});
</script></body>
</html>
